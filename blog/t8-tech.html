<!DOCTYPE html>
<html>
<head>
  <title>RegEx</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="../stylesheets/default.css">
  <link rel="stylesheet" type="text/css" href="../stylesheets/blog-stylesheet.css">
</head>
<body>
  <header class="banner">
  <img id="banner-photo" src="../imgs/banner-photo.jpg" / >
    <div id="social-media">
      <ul>
        <li>><a href="https://github.com/evanhughes3"><img src="../imgs/social_media_icons/Github.png" /></a></li>
        <li><a href="https://twitter.com/EvanHughes333"><img src="../imgs/social_media_icons/Twitter.png" /></a></li>
        <li><a href="https://www.linkedin.com/pub/evan-hughes/4a/ab8/1b4"><img src="../imgs/social_media_icons/Linkedin.png" /></a></li>
        <li><a href="https://www.facebook.com/evanhughes333"><img src="../imgs/social_media_icons/Facebook.png" /></a></li>
        <li><a href="https://plus.google.com/114186179917450271470/posts"><img src="../imgs/social_media_icons/Googleplus.png" /></a></li>
      </ul>
    </div>
  </header>

  <nav>
   <ul>
     <li><a href="../index.html">Home</a></li>
     <li><a href="../about.html">About</a></li>
     <li><a href="../projects_index.html">Projects</a></li>
     <li><a href="../blog_index.html">Blog</a></li>
     <li><a href="../contact.html">Contact</a></li>
    </ul>
  </nav>

<!--               - -->
<main>
   <header class="my-blog">
  <img id="banner-photo" src="../imgs/blog_title.jpg" / >
  </header>

<!--  -->

<main>
    <section class="blog-post">
      <article>
        <h1>Regular Expressions</h1>
        <br>
        <h3>"What the ^(?=*\d)" are they!?"</h3>
        <br>
        <center><img src="../imgs/reg_ex.gif"></a></center>
          <h4>1/22/14</h4>
        <br>
          <p>One topic I have coninued to come across during phase 0 was "regex" or Regular Expressions.  In some early challenges at DBC, they would have warning statements like "don't use Regular Expressions to solve this problem."  This got me thinking...so, regular expressions make solving this problem easy huh?  It's also hard to scan the pages of stackoverflow and not see regex's everywhere.  So, now that I'm a little more seasoned with all this stuff, I figure it's time to see what all the fuss is about.</p>

          <p> Regular Expressions help you find patterns.  By throwing a certain command out, a regex can search the page for specific patters, and shoot the information back to you.  I'm not going to lie, they look very complicated, but bare with me.  They are made up of literal characters (A, f, 1, 3) and metacharacters (^, \, $, *).  As an example, we're going to be examing this is the regex:</p>

<pre>^(?=.*\d).{4,8}$</pre>

          <p>Don't freak out, we'll break this down peice at a time.  This Regular Expression checks a user's password (you see, they are used everywhere!).  Not just any password will fly though, this password has to be between 4 and 8 characters long and include at least one numeric digit.  A good way to play around with regex's is using ".match(/.../)" in irb.  I'll show you in the examples.   Let's start by looking at the beginning, and end.</p>

<pre>
^        => start of a string
$        => end of a string


> "hello world".match(/^hello/)
=> #MatchData "hello">
> "hello world".match(/^ello/)
=> nil
> "hello world".match(/hello$/)
=> nil
> "hello world".match(/world$/)
=> #MatchData "world">
> "hello world".match(/orld$/)
=> #MatchData "orld">
> "hello world".match(/^hello world$/)
=> #MatchData "hello world">
> "hello world".match(/^hello worl$/) ## anything else besides "hello world" exactly would result in "nil"
=> nil

</pre>

          <p> So with our password, we're looking for a string, starting with ^... and ending with ...$.  The code in between ^ and $ is going explain the pattern.  Now lets took at the parenthesis, brackets, and the dot that falls in between them.</p>

<pre>
(...)     => Logical grouping of part of an expression
{...}     => Explicit quantifier notation
.          => Any character (except \n newline)

> "hello world".match(/(hello)/)
=> #MatchData "hello" 1:"hello">
> "hello world".match(/l{2}/)
=> #MatchData "ll">
irb(main):096:0> "hello world".match(/.{2}/)
=> #MatchData "he">
irb(main):099:0> "hello world".match(/.{4,8}/)
=> #MatchData "hello wo">
irb(main):100:0> "hello world".match(/.{20, 40}/)
=> nil
irb(main):101:0> "he".match(/.{4,8}/)
=> nil

</pre>


          <p>So just as you might group number's in parenthesis if you want them executed first, just think of the logical grouping of a certain part of your patter.  The brackets( {} ) signify a quantity, usually numbers will be inside of these.  Above, we simply matched any character (.) that was betwen {x,y} characters in length.  This is the enitire second part of our password function, see how much we're learning! So what we now know is we're looking for a pattern in ^(...){4,8}$ </p>

          <p>Let's take a look at one important metacharacter before we dive deeper.</p>
<pre>
*       => 0 or more of previous expression

> "hello world".match(/./)
=> #MatchData "h"
irb(main):146:0> "hello world".match(/../)
=> #MatchData "he">
irb(main):147:0> "hello world".match(/.../)
=> #MatchData "hel">
> "hello world".match(/.*/)
=> #MatchData "hello world">


</pre>
      <p>So in the first example, I asked it to match any character.  It did that, but it stopped there.  In the second and third example, I asked for it to match an 2 and 3 characters respectivly, but again it stopped there.  The * metacharacter continues with the previous expression until the end of the statement.</p>

      <p>Back to example.  Lets investigate two more parts.</p>
<pre>
?=     =>  Requires the given expression to match
\d      =>  Matches any decimal digit

> "hello world".match(/h(?=.)/)
=> #MatchData "h">
> "hello world".match(/h(?=e)/)
=> #MatchData "h">
> "hello world".match(/h(?=a)/)   ## a does not come after h in "hello" so it's not a match
=> nil

> "1234".match(/\d/)
=> #MatchData "1">
> "1234".match(/\d*/)
=> #MatchData "1234">

> "1234".match(/\d(?=2)/)
=> #MatchData "1">
> "1234".match(/\d(?=3)/)
=> #MatchData "2">

> "hello world".match(/\d/)
=> nil
</pre>

      <p> Think of the ? like an if statement.  If the next letter is "e", return the h, otherwise don't.  For an digit "\d" return the one if the next one is 3, etc.  That's a little confusing, but play around with them.  You may not beleive it, but we're ready to put it all together.  Let's take one last look at it.</p>

<pre>^(?=.*\d).{4,8}$</pre>

      <p> Match when: contained in the string starting with <em>^</em> and ending with <em>  $  </em>if <em>  (?=)  </em> any character <em>  (.)  </em> and any number more of previous expression <em>  (*)   </em>, contains a digit <em>  (\d)  </em>, and if all of that <em>    (.)   </em> is between 4 and 8 characters <em>   {4,8}  </em> you have a match! </p>

      <p>In other words, a password has to be between 4 and 8 characters long and include at least one numeric digit.  Holy cow, now lets try some examples of sample passwords.</p>

<pre>
> "evan33".match(/^(?=.*\d).{4,8}$/)     ## contains at least one number, between 4 and 8 characters, pass!
=> #MatchData "evan33">
> "evan".match(/^(?=.*\d).{4,8}$/)     ## no numbers, no match!
=> nil
> "33".match(/^(?=.*\d).{4,8}$/)     ## not enough characters!
=> nil
> "1234".match(/^(?=.*\d).{4,8}$/)    ## no need for letters, four numbers still passes!
=> #MatchData "1234">
> "evanhughes33".match(/^(?=.*\d).{4,8}$/)     ## too long!
=> nil
</pre>

      <p>That's about as techincal as I've gotten here.  Kudos to those of you who made it to the end.  I do think understanding more of real world example proves how helpful regex's are.  Now go practice on your own, and I'll do the same!</p>


        </article>
        <div class="back-button">
          <a href="../blog_index.html"><h4>Back to Blog Home</h4></a>
        </div>

  </section>
</main>

<footer>
  <p> <a href="./index.html">Home</a> |
    <a href="./about.html">About</a> |
    <a href="./projects_index.html">Projects</a> |
    <a href="./blog_index.html">Blog</a> |
    <a href="./contact.html">Contact</a> |
  </p>
  <p> Created by Evan Hughes 2014 </p>
</footer>
</body>
</html>

